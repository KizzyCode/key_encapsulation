= Kync v1
:toc:


== General
Kync describes a **K**e**Y**e**NC**apsulation format as well as a plugin-API for key encapsulation plugins.

Key encapsulation is the process of encrypting an already existing key with another different key. This is especially
useful if you want to use multiple different keys to open your data; e.g. an encrypted email with multiple recipients or
an encrypted file system with multiple users.


== Capsule Format
The capsule format describes the format of a key capsule.

The idea is to specify a well defined capsule format that can be decoded by any implementation but is flexible enough to
store an arbitrary amount of plugin-specific data. Therefore we include a version field, a format UID that specifies
which plugin can decode the capsule and a payload field for the plugin-specific data.


=== Encoding
The key-capsule uses the ASN.1-DER serialization, but in this document we use C++-like structs to describe the format.

We use the following types and map them like this:

 * A `struct` is serialized as an ASN.1-DER `SEQUENCE`
 * A `uint8_t`, `uint64_t` etc. is serialized as an ASN.1-DER `INTEGER`
 * A `char*` is serialized as an ASN.1-DER `UTF8String`
 * A `uint8_t*` is serialized as an ASN.1-DER `OctetString`
 * A `void*` indicates an unspecified type (similar to ASN.1-DER's `ANY`)

If possible, your plugin *SHOULD* also use the ASN.1-DER encoding for everything in `plugin_payload` and limit itself to
these 5 types. But if necessary, you can also use another ASN.1 type or wrap an arbitrary payload into an `uint8_t*`.


=== Format
A generic key capsule looks like this:
[source,cpp]
----
typedef struct {
    char* version;
    char* capsule_format_uid;
    void* plugin_payload;
} KeyCapsule;
----

An example of a real key capsule would look like this:
[source,cpp]
----
typedef struct {
    char* version;            // -> "de.KizzyCode.Kync.CapsuleV1"
    char* capsule_format_uid; // -> "AesGcmV1.B593CCDE-B5C3-433A-ABBA-9087FBF13E60"
    struct {
        uint8_t* chachapoly_nonce; // -> The AES-GCM nonce
        uint8_t* sealed_key;       // -> The AES-GCM-sealed key
    } plugin_payload;
} KeyCapsule;
----


==== Fields
 * `version`: The capsule-format version; always `de.KizzyCode.Kync.CapsuleV1` for this specification
 * `capsule_format_uid`: The payload format UID – this format-UID *MUST* map to one format only. To achieve this, we use
    a randomized suffix for our UIDs; e.g. `AesGcmV1.B593CCDE-B5C3-433A-ABBA-9087FBF13E60`. You *MAY* reimplement a
    format and use the same format UID if your plugin is *fully compatible* with the already existing format.
 * `plugin_payload`: The payload that is passed to the plugin. This payload *MUST* be a valid ASN.1-DER field and
   *SHOULD* be one of the four _specified_ types.


== Plugin API
To achive a simple and cross-platform compatible API, we use dynamic libraries that expose a C API/ABI.


=== General Rules
These general rules apply to all API functions and *MUST* be respected by the plugins that implement this API:

 1. Each function that can fail returns an <<Errors,error>>
 2. To pass data around, we use `slice_t`
 3. No ownership is transferred:
     - the slices passed to the plugin are allocated and freed by the caller
     - the slices returned by the plugin are constant memory that *MUST* be valid as long as the plugin is loaded
 4. An API-call *MUST NOT* take longer than 90 seconds before returning
 5. All functions *MUST* be threadsafe (provided that their parameters are threadsafe)


=== API Overview
These functions are defined by the API and *MUST* be implemented:

 - `init`: Takes care of the library initialization and API version validation
 - `capsule_format_uid`: Returns the capsule format UID for the implemented format
 - `buf_len_max`: Returns the *maximum* length a buffer will need for a given function
 - `capsule_key_ids`: Gets all available capsule key IDs (for plugins that have their own key storage; e.g. GnuPG)
 - `seal`: Seals some key bytes into a capsule
 - `open`: Extracts the key bytes from a capsule


=== init
[source,cpp]
----
error_t init(uint8_t api_version, uint8_t logging_level);
----

This function initializes the library and returns an <<Errors,`error_t`>> to check if the initialization failed.

Parameters:

 - `api_version`: The API version _expected by the caller_. The plugin *MUST* validate the expected version and return
   an error if it does not implement it. The API version defined by this document is `1`.
 - `logging_level`: The logging level the plugin should use (`0` means no logging). _Note: This only applies to StdErr_


=== capsule_format_uid
[source,cpp]
----
slice_t capsule_format_uid();
----

This function returns the capsule format UID for the format implemented by the library. It *MUST NOT* fail.


=== buf_len_max
[source,cpp]
----
size_t buf_len_max(slice_t const* fn_name);
----

This function returns the *maximum* length a buffer needs to store all data produced by a function. It *MUST NOT* fail
(return `0` in case of an invalid function name).

Parameter `fn_name`: The function name's bytes. The slice's length must be equal to the function name _without '\0'
termination_.


=== capsule_key_ids
[source,cpp]
----
error_t capsule_key_ids(slice_t* id_buffer);
----

This function writes all available capsule key IDs into `id_buffer`. This function is useful if the plugin offers it's
own key store that you can/must use (e.g. GnuPG).

The IDs are `uint8_t[256]`-arrays, which are just concatenated and written to `id_buffer` (whose length is then adjusted
accordingly). If an ID is shorter than 256 bytes, it *MUST* be '\0'-padded. The ID must be an UTF-8 string.

Parameter `id_buffer`: The buffer into which the IDs are written. To create a sufficiently large buffer, use
`buf_len_max`.


=== seal
[source,cpp]
----
error_t seal(
	uint8_t* der_tag, slice_t* der_payload,
	slice_t const* key_to_seal,
	slice_t const* capsule_key_id, slice_t const* user_secret
);
----

This function seals the key bytes in `key_to_seal` and writes the resulting DER data in `der_tag`/`der_payload`.

Parameters:

 - `der_tag`: A pointer to which the resulting DER tag is written; see <<Capsule Format>> for more information.
 - `der_payload`: The buffer into which the DER payload is written; see <<Capsule Format>> for more information.
 - `key_to_seal`: The slice containing the key bytes to seal
 - `capsule_key_id`: The capsule key ID to use (see `capsule_key_ids`). This parameter *MAY* be `NULL` if it's not
   necessary for the call.
 - `user_secret`: A user-provided secret. This parameter may have multiple, plugin-dependent purposes; ranging from a
   hardware-token-PIN to the capsule key itself. It *MAY* be `NULL` if it's not necessary for the call – however _if_ it
   is `NULL`, a plugin *MUST NOT* perform any authentication attempts that could decrease a retry counter.


=== open
[source,cpp]
----
error_t open(
	slice_t* key,
	uint8_t der_tag, slice_t const* der_payload,
	slice_t const* user_secret
);
----

This function opens a key capsule and writes the resulting key bytes into `key`.

Parameters:

 - `key`: The buffer to which the resulting key is written
 - `der_tag`: The DER tag; see <<Capsule Format>> for more information.
 - `der_payload`: The DER payload; see <<Capsule Format>> for more information.
 - `user_secret`: A user-provided secret. This parameter may have multiple, plugin-dependent purposes; ranging from a
   hardware-token-PIN to the capsule key itself. It *MAY* be `NULL` if it's not necessary for the call – however _if_ it
   is `NULL`, a plugin *MUST NOT* perform any authentication attempts that could decrease a retry counter.


=== slice_t
The slice type is a type that represents a contiguous region of memory where `data` is pointing to the begin of the
memory region, `len` announces the amount of valid memory.

[source,cpp]
----
typedef struct {
    uint8_t* data;
    size_t len;
} slice_t;
----


=== Errors
Errors are defines as a constant error type-ID plus some additional type-dependent error information:

[source,cpp]
----
typedef struct {
	uint8_t type_id[16]; // -> the error type as `\0`-padded string (e.g. "ENONE" or "EINIT")

	uint8_t file[256];   // -> the file where the error occurred as `\0`-padded string (e.g. "main.c")
	uint32_t line;       // -> the line where the error occurred
	uint8_t description[1024];   // -> an error description as `\0`-padded string

	uint64_t info;       // -> some type-dependent error info
} error_t;
----


==== ENONE
`ENONE` is the placeholder if no error occurred. `info` is unused.


==== EINIT
`EINIT` indicates a fatal error during library initialization. `info` is unused.


==== EPERM
`EPERM` indicates that an operation is not permitted (without providing authentication data).

`info` indicates if the action requires authentication (`!= 0`) or if the action will always fail (`== 0`).


==== EACCES
`EACCES` indicates an authentication error. `info` indicates the amount of retries left; if there is no retry-limit,
`info` is `UINT64_MAX`.


==== EIO
`EIO` indicates an I/O-related error. `info` is unused.


==== EILSEQ
`EILSEQ` indicates invalid capsule data. `info` is unused.


==== ENOKEY
`ENOKEY` indicates that there is no matching key available to decrypt the capsule. `info` is unused.


==== ECANCELED
`ECANCELED` indicates that the operation was canceled. `info` is unused.


==== ETIMEDOUT
`ETIMEDOUT` indicates that the operation timed out – either because it hit the 90s deadline or because something else
timed out (e.g. hardware token). `info` is unused.


==== EINVAL
`EINVAL` indicates that an API misuse occurred. `info` is the `0`-based index of the invalid argument.


==== EOTHER
`EOTHER` indicates that an unspecified fatal error occurred. `info` *MAY* be a plugin-specific error code and *MUST* be
ignored if it's meaning is unknown.